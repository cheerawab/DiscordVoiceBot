"""
Discord Voice Bot - ä½¿ç”¨ Faster-Whisper é€²è¡Œå³æ™‚ä¸²æµèªéŸ³è¾¨è­˜ (STT)

ä½¿ç”¨ discord.py + discord-ext-voice-recv æ¥æ”¶èªéŸ³ï¼Œ
æ­é… Faster-Whisper (CTranslate2) ä»¥æ»‘å‹•è¦–çª—æ–¹å¼é€²è¡Œå³æ™‚ä¸²æµè¾¨è­˜ã€‚

Faster-Whisper å„ªå‹¢ï¼š
  - æ¨è«–é€Ÿåº¦æ¯” OpenAI Whisper å¿« 4Ã— ä»¥ä¸Š
  - è¨˜æ†¶é«”ä½¿ç”¨é‡æ›´ä½
  - æ”¯æ´ VAD éæ¿¾ï¼Œè‡ªå‹•è·³ééœéŸ³æ®µ

é‹ä½œæ¨¡å¼ï¼š
  - æ¯ç´¯ç© CHUNK_SECONDS ç§’éŸ³è¨Šå°±é€å…¥ Whisper è¾¨è­˜ä¸€æ¬¡
  - èªªè©±ä¸­æŒçºŒç·¨è¼¯åŒä¸€å‰‡ Discord è¨Šæ¯ï¼Œå‘ˆç¾å³æ™‚æ›´æ–°æ•ˆæœ
  - éœéŸ³å¾Œå›ºå®šæœ€çµ‚è¾¨è­˜çµæœ

æŒ‡ä»¤:
  !join  - è®“æ©Ÿå™¨äººåŠ å…¥ä½ æ‰€åœ¨çš„èªéŸ³é »é“ï¼Œé–‹å§‹å³æ™‚èªéŸ³è¾¨è­˜
  !leave - è®“æ©Ÿå™¨äººé›¢é–‹èªéŸ³é »é“
"""

import os
import asyncio
import time
from collections import defaultdict

import discord
from discord.ext import commands
from discord.ext.voice_recv import VoiceRecvClient, BasicSink, VoiceData
from faster_whisper import WhisperModel
import numpy as np
from dotenv import load_dotenv

load_dotenv()

# â”€â”€â”€ è¨­å®š â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOKEN = os.getenv("DISCORD_TOKEN")
WHISPER_MODEL = os.getenv("WHISPER_MODEL", "base")   # tiny / base / small / medium / large-v3 / turbo
COMPUTE_TYPE = os.getenv("COMPUTE_TYPE", "int8")      # float16 / int8 / int8_float16 / float32
DEVICE = os.getenv("WHISPER_DEVICE", "auto")           # auto / cpu / cuda
TEXT_CHANNEL_ID = os.getenv("TEXT_CHANNEL_ID")        # å¯é¸ï¼šæŒ‡å®šè¼¸å‡ºè¾¨è­˜çµæœçš„æ–‡å­—é »é“ ID
LANGUAGE = os.getenv("WHISPER_LANGUAGE", "zh")        # é è¨­è¾¨è­˜èªè¨€

# ä¸²æµè¾¨è­˜è¨­å®š
CHUNK_SECONDS = 3.0         # æ¯éš”å¹¾ç§’é€è¾¨è­˜ä¸€æ¬¡ï¼ˆè¶ŠçŸ­è¶Šå³æ™‚ï¼Œä½†è¶Šè€—æ•ˆèƒ½ï¼‰
SILENCE_TIMEOUT = 1.5       # éœéŸ³è¶…éæ­¤ç§’æ•¸è¦–ç‚ºä¸€æ®µè©±çµæŸï¼Œå›ºå®šæœ€çµ‚çµæœ
MIN_AUDIO_DURATION = 1.0    # æœ€çŸ­éŸ³è¨Šé•·åº¦ï¼ˆç§’ï¼‰ï¼ŒéçŸ­å‰‡å¿½ç•¥
OVERLAP_SECONDS = 1.0       # èˆ‡å‰ä¸€æ®µé‡ç–Šçš„ç§’æ•¸ï¼Œé¿å…æ–·å¥ä¸å®Œæ•´
SAMPLE_RATE = 48000          # Discord èªéŸ³å–æ¨£ç‡
CHANNELS = 2                 # Discord èªéŸ³è²é“æ•¸ï¼ˆç«‹é«”è²ï¼‰
SAMPLE_WIDTH = 2             # 16-bit PCM = 2 bytes
WHISPER_SR = 16000           # Whisper éœ€è¦çš„å–æ¨£ç‡

# â”€â”€â”€ è¼‰å…¥ Faster-Whisper æ¨¡å‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
print(f"æ­£åœ¨è¼‰å…¥ Faster-Whisper æ¨¡å‹: {WHISPER_MODEL} (device={DEVICE}, compute_type={COMPUTE_TYPE}) ...")
whisper_model = WhisperModel(WHISPER_MODEL, device=DEVICE, compute_type=COMPUTE_TYPE)
print("Faster-Whisper æ¨¡å‹è¼‰å…¥å®Œæˆï¼")

# â”€â”€â”€ é™ä½ voice_recv çš„æ—¥èªŒå™ªéŸ³ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import logging
logging.getLogger("discord.ext.voice_recv.reader").setLevel(logging.WARNING)
logging.getLogger("discord.ext.voice_recv.gateway").setLevel(logging.WARNING)
logging.getLogger("discord.ext.voice_recv.opus").setLevel(logging.WARNING)
logging.getLogger("discord.ext.voice_recv.router").setLevel(logging.WARNING)

# â”€â”€â”€ Bot è¨­å®š â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Python 3.14 ä¸å†è‡ªå‹•å»ºç«‹ event loopï¼Œéœ€æ‰‹å‹•å»ºç«‹
loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)

intents = discord.Intents.default()
intents.message_content = True
intents.voice_states = True

bot = commands.Bot(command_prefix="!", intents=intents)


# â”€â”€â”€ ä½¿ç”¨è€…èªéŸ³ç‹€æ…‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class UserVoiceState:
    """è¿½è¹¤æ¯ä½ä½¿ç”¨è€…çš„èªéŸ³ç·©è¡å€èˆ‡å³æ™‚è¾¨è­˜ç‹€æ…‹"""

    def __init__(self):
        # éŸ³è¨Šç·©è¡å€
        self.buffer = bytearray()
        self.last_packet_time: float = 0.0

        # ä¸²æµè¾¨è­˜ç‹€æ…‹
        self.current_message: discord.Message | None = None  # æ­£åœ¨ç·¨è¼¯çš„è¨Šæ¯
        self.accumulated_text: str = ""                       # æ­¤æ®µå·²ç¢ºèªçš„æ–‡å­—
        self.last_chunk_time: float = 0.0                     # ä¸Šæ¬¡é€è¾¨è­˜çš„æ™‚é–“
        self.is_speaking: bool = False                         # æ˜¯å¦æ­£åœ¨èªªè©±
        self.processing: bool = False                          # æ˜¯å¦æ­£åœ¨è¾¨è­˜ä¸­

    def add_data(self, data: bytes):
        self.buffer.extend(data)
        self.last_packet_time = time.time()
        if not self.is_speaking:
            self.is_speaking = True
            self.last_chunk_time = time.time()

    def get_duration(self) -> float:
        return len(self.buffer) / (SAMPLE_RATE * CHANNELS * SAMPLE_WIDTH)

    def consume(self) -> bytes:
        data = bytes(self.buffer)
        self.buffer.clear()
        return data

    def consume_with_overlap(self) -> bytes:
        """å–å‡ºéŸ³è¨Šï¼Œä½†ä¿ç•™å°¾éƒ¨ä½œç‚ºé‡ç–Šå€æ®µ"""
        overlap_bytes = int(OVERLAP_SECONDS * SAMPLE_RATE * CHANNELS * SAMPLE_WIDTH)
        data = bytes(self.buffer)
        if len(self.buffer) > overlap_bytes:
            # ä¿ç•™æœ€å¾Œ overlap çš„éƒ¨åˆ†
            self.buffer = bytearray(self.buffer[-overlap_bytes:])
        else:
            self.buffer.clear()
        return data

    def is_silent_for(self, timeout: float) -> bool:
        if self.last_packet_time == 0:
            return False
        return (time.time() - self.last_packet_time) > timeout

    def time_since_last_chunk(self) -> float:
        if self.last_chunk_time == 0:
            return 0
        return time.time() - self.last_chunk_time

    def reset_session(self):
        """é‡ç½®æ­¤æ®µå°è©±ç‹€æ…‹ï¼ˆä¿ç•™ buffer ä¾›ä¸‹æ¬¡ä½¿ç”¨ï¼‰"""
        self.current_message = None
        self.accumulated_text = ""
        self.is_speaking = False
        self.processing = False


# â”€â”€â”€ PCM â†’ Whisper è½‰æ›å·¥å…· â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def pcm_to_whisper_array(pcm_data: bytes) -> np.ndarray | None:
    """å°‡ PCM éŸ³è¨Šè½‰æ›ç‚º Faster-Whisper éœ€è¦çš„ 16kHz float32 mono numpy array"""
    samples = np.frombuffer(pcm_data, dtype=np.int16).astype(np.float32) / 32768.0
    if len(samples) == 0:
        return None

    # ç«‹é«”è² â†’ å–®è²é“
    if CHANNELS == 2:
        samples = samples.reshape(-1, 2).mean(axis=1)

    # é™å–æ¨£ 48kHz â†’ 16kHz
    ratio = SAMPLE_RATE // WHISPER_SR  # 3
    samples = samples[::ratio]

    if len(samples) < int(WHISPER_SR * MIN_AUDIO_DURATION):
        return None

    return samples


def run_whisper(audio: np.ndarray) -> str:
    """åŒæ­¥åŸ·è¡Œ Faster-Whisper æ¨è«–ï¼Œå›å‚³è¾¨è­˜æ–‡å­—"""
    segments, _info = whisper_model.transcribe(
        audio,
        language=LANGUAGE,
        beam_size=5,
        vad_filter=True,           # ä½¿ç”¨ VAD éæ¿¾éœéŸ³æ®µ
        vad_parameters=dict(
            min_silence_duration_ms=500,
        ),
    )
    text = "".join(seg.text for seg in segments).strip()
    return text


# â”€â”€â”€ èªéŸ³ç®¡ç†å™¨ï¼ˆä¸²æµæ¨¡å¼ï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class VoiceManager:
    """
    å³æ™‚ä¸²æµèªéŸ³è¾¨è­˜ç®¡ç†å™¨ã€‚

    é‹ä½œæµç¨‹ï¼š
    1. æ”¶åˆ°èªéŸ³å°åŒ… â†’ ç´¯ç©åˆ°ä½¿ç”¨è€…çš„ buffer
    2. æ¯éš” CHUNK_SECONDS ç§’ï¼Œå–å‡º buffer é€ Whisper è¾¨è­˜
    3. è¾¨è­˜çµæœå³æ™‚æ›´æ–°ï¼ˆç·¨è¼¯ï¼‰åŒä¸€å‰‡ Discord è¨Šæ¯
    4. åµæ¸¬åˆ°éœéŸ³ â†’ å›ºå®šæœ€çµ‚çµæœï¼Œæº–å‚™ä¸‹ä¸€æ®µ
    """

    def __init__(self, text_channel: discord.TextChannel, bot_instance: commands.Bot):
        self.text_channel = text_channel
        self.bot_instance = bot_instance
        self.user_states: dict[int, UserVoiceState] = defaultdict(UserVoiceState)
        self._running = True
        self._monitor_task: asyncio.Task | None = None

    def start(self):
        self._monitor_task = self.bot_instance.loop.create_task(self._monitor_loop())

    def stop(self):
        self._running = False
        if self._monitor_task:
            self._monitor_task.cancel()
        self.user_states.clear()

    def on_voice_data(self, member: discord.Member | discord.User | None, voice_data: VoiceData):
        """BasicSink å›å‘¼ï¼šæ”¶åˆ° PCM èªéŸ³è³‡æ–™"""
        if member is None:
            return
        pcm = voice_data.pcm
        if pcm:
            self.user_states[member.id].add_data(pcm)

    async def _monitor_loop(self):
        """ä¸»è¿´åœˆï¼šåµæ¸¬ä¸²æµè¾¨è­˜æ™‚æ©Ÿèˆ‡éœéŸ³çµæŸ"""
        while self._running:
            await asyncio.sleep(0.2)

            for uid, state in list(self.user_states.items()):
                if not state.is_speaking:
                    continue

                # æƒ…æ³ 1ï¼šéœéŸ³è¶…æ™‚ â†’ æœ€çµ‚è¾¨è­˜ä¸¦å›ºå®šçµæœ
                if state.is_silent_for(SILENCE_TIMEOUT):
                    if state.get_duration() >= MIN_AUDIO_DURATION and not state.processing:
                        state.processing = True
                        pcm_data = state.consume()
                        asyncio.create_task(self._finalize(uid, pcm_data, state))
                    elif state.get_duration() < MIN_AUDIO_DURATION:
                        # å‰©é¤˜éŸ³è¨Šå¤ªçŸ­ï¼Œç›´æ¥çµæŸæ­¤æ®µ
                        state.buffer.clear()
                        state.reset_session()

                # æƒ…æ³ 2ï¼šç´¯ç©è¶³å¤ æ™‚é–“ â†’ ä¸²æµè¾¨è­˜ï¼ˆä¸­é–“çµæœï¼‰
                elif (state.time_since_last_chunk() >= CHUNK_SECONDS
                      and state.get_duration() >= MIN_AUDIO_DURATION
                      and not state.processing):
                    state.processing = True
                    state.last_chunk_time = time.time()
                    pcm_data = state.consume_with_overlap()
                    asyncio.create_task(self._stream_transcribe(uid, pcm_data, state))

    async def _stream_transcribe(self, user_id: int, pcm_data: bytes, state: UserVoiceState):
        """ä¸²æµè¾¨è­˜ï¼šä¸­é–“çµæœï¼Œç·¨è¼¯åŒä¸€å‰‡è¨Šæ¯"""
        try:
            audio = pcm_to_whisper_array(pcm_data)
            if audio is None:
                state.processing = False
                return

            text = await asyncio.get_running_loop().run_in_executor(None, run_whisper, audio)
            if not text:
                state.processing = False
                return

            # çµ„åˆï¼šå·²ç¢ºèªæ–‡å­— + æœ¬æ¬¡æ–°è¾¨è­˜
            display_text = (state.accumulated_text + text).strip()
            if not display_text:
                state.processing = False
                return

            member = self.text_channel.guild.get_member(user_id)
            name = member.display_name if member else f"User#{user_id}"
            content = f"ğŸ™ï¸ **{name}**ï¼š{display_text} ..."

            if state.current_message is None:
                # ç¬¬ä¸€æ¬¡ï¼šç™¼é€æ–°è¨Šæ¯
                state.current_message = await self.text_channel.send(content)
            else:
                # å¾ŒçºŒï¼šç·¨è¼¯åŒä¸€å‰‡è¨Šæ¯
                await state.current_message.edit(content=content)

            # å°‡æœ¬æ¬¡çµæœåŠ å…¥å·²ç¢ºèªæ–‡å­—
            state.accumulated_text += text

        except Exception as e:
            print(f"[ä¸²æµè¾¨è­˜éŒ¯èª¤] user_id={user_id}: {e}")
        finally:
            state.processing = False

    async def _finalize(self, user_id: int, pcm_data: bytes, state: UserVoiceState):
        """æœ€çµ‚è¾¨è­˜ï¼šéœéŸ³å¾Œå›ºå®šçµæœ"""
        try:
            audio = pcm_to_whisper_array(pcm_data)

            # çµ„åˆæœ€çµ‚æ–‡å­—
            final_new = ""
            if audio is not None:
                final_new = await asyncio.get_running_loop().run_in_executor(None, run_whisper, audio)

            final_text = (state.accumulated_text + final_new).strip()

            if not final_text:
                state.reset_session()
                return

            member = self.text_channel.guild.get_member(user_id)
            name = member.display_name if member else f"User#{user_id}"
            content = f"ğŸ™ï¸ **{name}**ï¼š{final_text}"

            if state.current_message is None:
                await self.text_channel.send(content)
            else:
                # ç§»é™¤å°¾éƒ¨ "..." ä¸¦å›ºå®šæœ€çµ‚çµæœ
                await state.current_message.edit(content=content)

        except Exception as e:
            print(f"[æœ€çµ‚è¾¨è­˜éŒ¯èª¤] user_id={user_id}: {e}")
        finally:
            state.reset_session()


# å„²å­˜æ¯å€‹ guild çš„ VoiceManager å¯¦ä¾‹
voice_managers: dict[int, VoiceManager] = {}


# â”€â”€â”€ Bot äº‹ä»¶ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@bot.event
async def on_ready():
    print(f"Bot å·²ä¸Šç·šï¼š{bot.user} (ID: {bot.user.id})")
    print("------")


# â”€â”€â”€ æŒ‡ä»¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@bot.command(name="join", help="è®“æ©Ÿå™¨äººåŠ å…¥ä½ æ‰€åœ¨çš„èªéŸ³é »é“")
async def join(ctx: commands.Context):
    # æª¢æŸ¥ä½¿ç”¨è€…æ˜¯å¦åœ¨èªéŸ³é »é“
    if not ctx.author.voice or not ctx.author.voice.channel:
        await ctx.send("âŒ ä½ å¿…é ˆå…ˆåŠ å…¥ä¸€å€‹èªéŸ³é »é“ï¼")
        return

    voice_channel = ctx.author.voice.channel

    # å¦‚æœ Bot å·²åœ¨æŸèªéŸ³é »é“ï¼Œå…ˆæ–·é–‹
    if ctx.voice_client:
        # åœæ­¢èˆŠçš„ VoiceManager
        old_mgr = voice_managers.pop(ctx.guild.id, None)
        if old_mgr:
            old_mgr.stop()
        try:
            ctx.voice_client.stop_listening()
        except Exception:
            pass
        await ctx.voice_client.disconnect(force=True)
        await asyncio.sleep(1)  # ç­‰å¾…æ–·ç·šå®Œå…¨å®Œæˆ

    # ä½¿ç”¨ VoiceRecvClient é€£æ¥èªéŸ³é »é“ï¼ˆæ”¯æ´æ¥æ”¶èªéŸ³ï¼‰ï¼ŒåŠ å¤§ timeout ä¸¦é‡è©¦
    vc = None
    for attempt in range(3):
        try:
            vc = await voice_channel.connect(cls=VoiceRecvClient, timeout=30.0)
            break
        except TimeoutError:
            print(f"[èªéŸ³é€£ç·š] ç¬¬ {attempt + 1} æ¬¡å˜—è©¦è¶…æ™‚...")
            # æ¸…ç†æ®˜ç•™çš„ voice_client
            if ctx.voice_client:
                try:
                    await ctx.voice_client.disconnect(force=True)
                except Exception:
                    pass
                await asyncio.sleep(2)

    if vc is None:
        await ctx.send("âŒ ç„¡æ³•é€£æ¥åˆ°èªéŸ³é »é“ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚")
        return

    # æ±ºå®šè¾¨è­˜çµæœè¼¸å‡ºçš„æ–‡å­—é »é“
    text_channel = ctx.channel
    if TEXT_CHANNEL_ID:
        ch = bot.get_channel(int(TEXT_CHANNEL_ID))
        if ch is not None:
            text_channel = ch

    # å»ºç«‹ VoiceManager ä¸¦é–‹å§‹ç›£è½
    mgr = VoiceManager(text_channel, bot)
    voice_managers[ctx.guild.id] = mgr

    # ä½¿ç”¨ BasicSink æ¥æ”¶ PCM è³‡æ–™ï¼Œå›å‘¼åˆ° VoiceManager
    sink = BasicSink(mgr.on_voice_data)
    vc.listen(sink)
    mgr.start()

    await ctx.send(
        f"âœ… å·²åŠ å…¥èªéŸ³é »é“ï¼š**{voice_channel.name}**\n"
        f"ğŸ§ é–‹å§‹ç›£è½èªéŸ³ï¼Œè¾¨è­˜çµæœå°‡é¡¯ç¤ºåœ¨æ­¤é »é“ã€‚\n"
        f"ğŸ“ æ¨¡å‹ï¼š`{WHISPER_MODEL}` ï½œèªè¨€ï¼š`{LANGUAGE}`"
    )


@bot.command(name="leave", help="è®“æ©Ÿå™¨äººé›¢é–‹èªéŸ³é »é“")
async def leave(ctx: commands.Context):
    if not ctx.voice_client:
        await ctx.send("âŒ æˆ‘ç›®å‰ä¸åœ¨ä»»ä½•èªéŸ³é »é“ä¸­ã€‚")
        return

    # åœæ­¢ VoiceManager
    mgr = voice_managers.pop(ctx.guild.id, None)
    if mgr:
        mgr.stop()

    # åœæ­¢ç›£è½ä¸¦æ–·é–‹é€£ç·š
    try:
        ctx.voice_client.stop_listening()
    except Exception:
        pass
    await ctx.voice_client.disconnect()
    await ctx.send("ğŸ‘‹ å·²é›¢é–‹èªéŸ³é »é“ã€‚")


# â”€â”€â”€ å•Ÿå‹• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if __name__ == "__main__":
    if not TOKEN:
        print("éŒ¯èª¤ï¼šè«‹åœ¨ .env æª”æ¡ˆä¸­è¨­å®š DISCORD_TOKEN")
        exit(1)
    bot.run(TOKEN)
